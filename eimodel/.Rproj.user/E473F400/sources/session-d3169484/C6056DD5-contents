# Note: For running the test we'll define a helper function for simulating random voting
# instances. This function will also be tested for sanity purposes => if this function
# fails everything fails.

simulate_votation <- function(num_ballots, candidate_alpha, num_demographics,
                              demographic_alpha = rep(1, num_demographics),
                              total_votes = 100) {
    # If total_votes is a single number, make it a vector (one total per ballot box)
    if (length(total_votes) == 1) {
        total_votes <- rep(total_votes, num_ballots)
    } else if (length(total_votes) != num_ballots) {
        stop("total_votes must be either a single number or a vector of length num_ballots")
    }

    num_candidates <- length(candidate_alpha)

    # Preallocate matrices:
    # X will be (ballot boxes x candidates)
    X <- matrix(0, nrow = num_ballots, ncol = num_candidates)
    # W will be (demographic groups x ballot boxes)
    W <- matrix(0, nrow = num_demographics, ncol = num_ballots)

    # Function to generate a Dirichlet draw.
    # It draws 'n' samples, each of length = length(alpha)
    rdirichlet <- function(n, alpha) {
        k <- length(alpha)
        samples <- matrix(rgamma(n * k, shape = alpha, rate = 1), ncol = k, byrow = TRUE)
        samples / rowSums(samples)
    }

    # Loop over ballot boxes
    for (i in 1:num_ballots) {
        # --- Candidate votes ---
        # Draw candidate vote shares for ballot box i:
        p <- rdirichlet(1, candidate_alpha)
        # Allocate the total_votes[i] among candidates:
        votes_candidates <- as.vector(rmultinom(1, size = total_votes[i], prob = p))
        X[i, ] <- votes_candidates

        # --- Demographic votes ---
        # Draw demographic vote shares for ballot box i:
        q <- rdirichlet(1, demographic_alpha)
        # Allocate the same total votes among demographics:
        votes_demographics <- as.vector(rmultinom(1, size = total_votes[i], prob = q))
        W[, i] <- votes_demographics
    }

    # At this point, for each ballot box i:
    #   sum(X[i, ]) == total_votes[i]  and  sum(W[, i]) == total_votes[i].
    # That is, the candidate vote totals (by ballot box) equal the demographic vote totals.

    return(list(X = X, W = W))
}

tests <- 10 # Number of random tests to run
# ========= Sampling simulation test ========= #
test_that("The sampling function works", {
    for (i in 1:tests) {
        # Randomly draw the number of ballots, candidates and dirichlet parameters
        # Randomly choose a ballot box between 5 and 50
        num_ballots <- sample(5:50, 1)
        # Randomly choose a candidate between 1 and 5
        num_candidates <- sample(1:5, 1)
        # Randomly choose dirichlet parameters for each candidate between (0.1, 3)
        candidate_alpha <- runif(num_candidates, 0.1, 3)
        # Randomly choose demographic groups between 1 and 5
        num_demographics <- sample(2:5, 1)
        # Randomly choose dirichlet parameters for each demographic group between (0.5, 3)
        demographic_alpha <- runif(num_demographics, 0.5, 3)
        # Randomly choose the total amount of votes per ballot box
        total_votes <- sample(50:150, 1)

        result <- simulate_votation(
            num_ballots = num_ballots,
            candidate_alpha = candidate_alpha,
            num_demographics = num_demographics,
            demographic_alpha = demographic_alpha,
            total_votes = total_votes
        )

        # Check that for each ballot box, the candidate votes (rows of X) match the demographic votes (columns of W)
        expect_equal(rowSums(result$X), colSums(result$W))
        # Check that the candidate dimension is coherent with the amount of candidates
        expect_equal(ncol(result$X), num_candidates)
        # Check that the group dimension is coherent with the amount of candidates
        expect_equal(nrow(result$W), num_demographics)
        # Check that the X and W dimensions are coherent with the ballot box amount
        expect_equal(nrow(result$X), num_ballots)
        expect_equal(ncol(result$W), num_ballots)
    }
})

# ========= Constructor function test ========= #
testing_model <- rxc$new(X, W)
test_that("The constructor works", {
    # The "border case" would be to handle the case where there's no votes for a candidate
    for (i in 1:tests) {
        constructor_simulation <- simulate_votation(
            num_ballots = 100,
            candidate_alpha = c(0, 3, 1, 2),
            num_demographics = 5,
            demographic_alpha = c(0, 1, 2, 3, 4),
            total_votes = 400
        )

        # Construct the model
        constructing_model <- rxc$
            # Check if it's equal to the X matrix
            expect_equal(testing_model$X, X)
    }
})
