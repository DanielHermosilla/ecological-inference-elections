---
title: "Demonstration of the package usage"
author: "Daniel Hermosilla"
date: "`r Sys.Date()`"

vignette: >
  %\VignetteIndexEntry{Demonstration of the package usage}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}

output:
  rmarkdown::html_vignette:
    toc: false
    number_sections: false
---

The `fastei` library implements the Expectation-Maximization algorithm to estimate probabilities in non-parametric Ecological Inference for the RxC case. It offers both an exact method and four approximation methods suitable for large datasets. The application demonstrated here is based on an electoral context where, for each ballot box, we know the number of voters in each demographic group and the number of votes received by each candidate.

# Estimate Voting Probabilities
We use data from the First Round of the Chilean Presidential Election of 2021, where at each ballot box we have the voters of eight age ranges (groups), and candidate votes obtained. The function `get_XW_chile()` loads this data at either the country, region, or electoral district level.

```{r}
library(fastei)

apoquindo <- get_XW_chile(elect_district = "APOQUINDO")

apoquindo
```

As shown in the output, it returns an eim object that contains two matrices: the number of votes per candidate and the number of votes per group. The rows of both matrices correspond to the specific ballot-box, and the columns are candidates and groups, respectively. This eim object is used as input to run the EM algorithm that estimates the voting probabilities. In this example, it uses the default method `mult`, which is the most efficient in terms of runtime.
Running the algorithm is done by calling `run_em()`.

```{r}
results <- run_em(apoquindo, allow_mismatch = TRUE)
results$prob
```

Note that each row corresponds to the probability that a demographic group (`g`) voted for a candidate (`c`). It is worth noting how the estimated probabilities differ substantially across groups.

# Standard deviation estimates

We can compute the standard deviation of the estimated probabilities using bootstrapping. This can be done with the function `bootstrap()`.

```{r}
results <- bootstrap(results, seed = 42, nboot = 30, allow_mismatch = TRUE)
results$sd
```

The standard deviations obtained in the district "Apoquindo" are low in general. One reason for this is the high number of ballot boxes in this district. In contrast, standard deviations of estimated probabilities in districts with fewer ballot boxes, such as "Navidad", are larger.

```{r}
navidad <- get_XW_chile(elect_district = "NAVIDAD")
navidad <- bootstrap(navidad, seed = 42, nboot = 30, allow_mismatch = TRUE)
navidad$sd
```


# Reduce Estimation Error using Group Aggregation

Demographic groups can be merged to have probability estimates with lower error. A greedy strategy that maximizes the variability of the distribution of groups across ballot boxes is used, which ensures standard deviations are below a specific threshold. The package provides the following function for the latter:

```{r}
navidad_proxy <- get_agg_proxy(navidad, seed = 42, sd_threshold = 0.125, sd_statistic = "average", allow_mismatch = TRUE)
navidad_proxy$group_agg
```

As shown in the output, the heuristic found a feasible configuration by merging groups 1 with 2. We can evaluate the effectiveness of this grouping by comparing the mean standard deviation to the original formulation:

```{r}
mean(navidad$sd) - mean(navidad_proxy$sd)
```

An exhaustive algorithm is also included in the package. It explores all combinations of adjacent groups in order to maximize the log-likelihood subject to having standard deviations below a given threshold. It might require substantial computation time; therefore it is recommended to use the default method, "mult".

```{r}
navidad_opt <- get_agg_opt(navidad, seed = 42, sd_threshold = 0.125, sd_statistic = "average", allow_mismatch = TRUE)
navidad_opt$group_agg
```

The optimal group aggregation differs slightly from one obtained before.

# Test difference between estimates

A relevant question is how significantly different are the probability estimates of two sets of data, such as two different districts. For instance, we can compare the estimated probabilities of the district "APOQUINDO" and "PROVIDENCIA", which belong to the same ward. A Welch's test can be applied to each component of the two probability matrix estimates:

```{r}
providencia <- get_XW_chile(elect_district = "PROVIDENCIA")

comparison <- welchtest(
    object = providencia,
    object2 = apoquindo,
    allow_mismatch = TRUE,
    method = "mult",
    nboot = 30,
    seed = 42
)

round(comparison$pvals, 3)
```

In most cases, voting probabilities are not significantly different. On the other hand, it may be noteworthy to observe the difference between two electoral districts whose voting tendencies are expected to differ.

```{r}
la_granja <- get_XW_chile(elect_district = "LA GRANJA")
lo_barnechea <- get_XW_chile(elect_district = "LO BARNECHEA")

comparison2 <- welchtest(
    object = la_granja,
    object2 = lo_barnechea,
    allow_mismatch = TRUE,
    method = "mult",
    nboot = 30,
    seed = 42
)

round(comparison2$pvals, 3)
```


# Simulating Election Results

In this section, we simulate election data multiple times to evaluate the accuracy and speed of each method on average.

We generate random elections with 2 groups, 2 candidates, and 50 ballots, and repeat each method **10 times** to calculate their average performance.

```{r}
# Helper to repeat and average
benchmark_method <- function(method_name, ..., reps = 10) {
    maes <- numeric(reps)
    times <- numeric(reps)

    for (i in seq_len(reps)) {
        samples <- simulate_election(num_groups = 2, num_candidates = 2, num_ballots = 50, seed = i)
        object <- eim(samples$X, samples$W)

        result <- run_em(object, method = method_name, ...)

        maes[i] <- mean(abs(result$prob - samples$real_prob))
        times[i] <- result$time
    }

    list(
        avg_mae = mean(maes),
        avg_time = mean(times)
    )
}
```

## Multinomial

The multinomial method offers a fast and simple approximation based on the observed votes and prior probabilities. It is ideal for quick estimates, with low computational cost and good overall accuracy for moderately complex elections.

```{r}
multinomial_result <- benchmark_method("mult")
multinomial_result
```

## Multivariate PDF

The multivariate PDF method refines the multinomial approximation by accounting for the local shape of the probability distribution.

```{r}
multivariate_pdf_result <- benchmark_method("mvn_pdf")
multivariate_pdf_result
```

## Multivariate CDF

The multivariate CDF method approximates first and second moments of the posterior by integrating over small regions of the multivariate normal distribution. It provides better control over uncertainty at the cost of higher computation, especially if a tight Monte Carlo error is required.

```{r}
multivariate_cdf_result <- benchmark_method("mvn_cdf")
multivariate_cdf_result
```

## MCMC

The MCMC method explores possible voting configurations by random sampling, providing very flexible and accurate results. It typically incurs an initial computational cost to generate valid samples, but after reaching a sufficient number of samples, each additional iteration becomes relatively fast and efficient.

```{r}
mcmc_result <- benchmark_method("mcmc", samples = 1000, step_size = 2000)
mcmc_result
```

## Exact

The exact method computes all possible voting configurations exhaustively. It guarantees the highest theoretical accuracy but becomes quickly infeasible for elections with many candidates, groups, or ballots due to its exponential computational complexity.

```{r}
exact_result <- benchmark_method("exact")
exact_result
```

