---
title: "Demonstration of the package usage"
author: "Daniel Hermosilla"
date: "`r Sys.Date()`"

vignette: >
  %\VignetteIndexEntry{Demonstration of the package usage}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}

output:
  rmarkdown::html_vignette:
    toc: false
    number_sections: false
---

The `fastei` library implements the Expectation-Maximization algorithm to estimate probabilities in non-parametric Ecological Inference for the RxC case. It offers both an exact method and four approximation methods suitable for large datasets. The application demonstrated here is based on an electoral context where, for each ballot box, we know the number of voters in each demographic group and the number of votes received by each candidate.

# Estimate Voting Probabilities
We use data from the First Round of the Chilean Presidential Election of 2021, where at each ballot box we have the voters of eight age ranges (groups), and candidate votes obtained. The function `get_XW_chile()` loads this data at either the country, region, or electoral district level.

```{r}
library(fastei)

apoquindo <- get_XW_chile(elect_district = "APOQUINDO")

apoquindo
```

As shown in the output, it returns an eim object that contains two matrices: the number of votes per candidate and the number of votes per group. The rows of both matrices correspond to the specific ballot-box, and the columns are candidates and groups, respectively. This eim object is used as input to run the EM algorithm that estimates the voting probabilities. In this example, it uses the default method `mult`, which is the most efficient in terms of runtime.
Running the algorithm is done by calling `run_em()`.

```{r}
results <- run_em(apoquindo, allow_mismatch = TRUE)
results$prob
```

Note that each row corresponds to the probability that a demographic group (`g`) voted for a candidate (`c`). It is worth noting how the estimated probabilities differ substantially across groups.

# Standard deviation estimates

We can compute the standard deviation of the estimated probabilities using bootstrapping. This can be done with the function `bootstrap()`.

```{r}
results <- bootstrap(results, seed = 42, nboot = 30, allow_mismatch = TRUE)
results$sd
```

The standard deviations obtained in the district "Apoquindo" are low in general. One reason for this is the high number of ballot boxes in this district. In contrast, standard deviations of estimated probabilities in districts with fewer ballot boxes, such as "Navidad", are larger.

```{r}
navidad <- get_XW_chile(elect_district = "NAVIDAD")
navidad <- bootstrap(navidad, seed = 42, nboot = 30, allow_mismatch = TRUE)
navidad$sd
```


# Reduce Estimation Error using Group Aggregation

Demographic groups can be merged to have probability estimates with lower error. A greedy strategy that maximizes the variability of the distribution of groups across ballot boxes is used, which ensures standard deviations are below a specific threshold. The package provides the following function for the latter:

```{r}
navidad_proxy <- get_agg_proxy(navidad, seed = 42, sd_threshold = 0.125, sd_statistic = "average", allow_mismatch = TRUE)
navidad_proxy$group_agg
```

As shown in the output, the heuristic found a feasible configuration by merging groups 1 with 2. We can evaluate the effectiveness of this grouping by comparing the mean standard deviation to the original formulation:

```{r}
mean(navidad$sd) - mean(navidad_proxy$sd)
```

An exhaustive algorithm is also included in the package. It explores all combinations of adjacent groups in order to maximize the log-likelihood subject to having standard deviations below a given threshold. It might require substantial computation time; therefore it is recommended to use the default method, "mult".

```{r}
navidad_opt <- get_agg_opt(navidad, seed = 42, sd_threshold = 0.125, sd_statistic = "average", allow_mismatch = TRUE)
navidad_opt$group_agg
```

The optimal group aggregation differs slightly from one obtained before.

# Test difference between estimates

A relevant question is how significantly different are the probability estimates of two sets of data, such as two different districts. For instance, we can compare the estimated probabilities of the district "APOQUINDO" and "PROVIDENCIA", which belong to the same ward.

```{r, message=FALSE, warning=FALSE}
library(ggplot2)
library(reshape2)
library(viridis)

plot_district <- function(district1, district2) {
    # Run EM algorithm for both districts
    em1 <- run_em(get_XW_chile(elect_district = toupper(district1)))
    em2 <- run_em(get_XW_chile(elect_district = toupper(district2)))

    df1 <- melt(em1$prob)
    df2 <- melt(em2$prob)
    df1$Matrix <- district1
    df2$Matrix <- district2
    combined_df <- rbind(df1, df2)

    # Add text to each cell of the matrix
    value_range <- range(combined_df$value, na.rm = TRUE)
    combined_df$label <- sprintf("%.2f", combined_df$value)
    combined_df$text_color <- ifelse(combined_df$value > 0.5, "black", "white")

    # Call the plot
    ggplot(combined_df, aes(x = Var2, y = Var1, fill = value)) +
        geom_tile() +
        geom_text(aes(label = label, color = text_color), size = 3) +
        scale_fill_viridis(
            name = "Probability",
            limits = value_range,
            option = "viridis"
        ) +
        scale_color_identity() +
        facet_wrap(~Matrix) +
        coord_fixed() +
        theme_bw() +
        labs(
            title = paste("Predicted probabilities between", district1, "and", district2),
            x = "Candidate votes", y = "Voter's age range", fill = "Probability"
        ) +
        theme(
            strip.text = element_text(size = 12),
            plot.title = element_text(size = 16, hjust = 0.5)
        )
}
```

```{r prov_apoq_comparison, fig.width = 8, fig.height = 6.5, fig.cap = "Providencia and Apoquindo comparison", fig.align = "center", message=FALSE, warning=FALSE, results="hide"}
plot_district("Apoquindo", "Providencia")
```

A Welch's test can be applied to each component of the two probability matrix estimates:

```{r}
providencia <- get_XW_chile("PROVIDENCIA")

comparison <- welchtest(
    object = providencia,
    object2 = apoquindo,
    allow_mismatch = TRUE,
    method = "mult",
    nboot = 30,
    seed = 42
)

round(comparison$pvals, 3)
```

In most cases, voting probabilities are not significantly different. On the other hand, it may be noteworthy to observe the difference between two electoral districts whose voting tendencies are expected to differ.

```{r granja_lobarnechea_comparison, fig.width = 8, fig.height=6.5, fig.cap = "Lo Barnechea and La Granja comparison", fig.align = "center", message=FALSE, warning=FALSE, results="hide"}
plot_district("La Granja", "Lo Barnechea")
```


```{r}
la_granja <- get_XW_chile("LA GRANJA")
lo_barnechea <- get_XW_chile("LO BARNECHEA")

comparison2 <- welchtest(
    object = la_granja,
    object2 = lo_barnechea,
    allow_mismatch = TRUE,
    method = "mult",
    nboot = 30,
    seed = 42
)

round(comparison2$pvals, 3)
```


# Simulating Election Results

It is possible to simulate an artificial election and get its values as an eim object with the simulated probability. This is useful for testing the package's performance and comparing the different methods available.

```{r}
election_values <- simulate_election(num_ballots = 50, num_groups = 2, num_candidates = 2, seed = 42)
election_values$real_prob
```

```{r}
election_values <- run_em(election_values)
election_values$prob
```

Moreover, it is possible to handle a given probability matrix as the simulated probability, leaving the sorting aspect to the function.

```{r}
artificial_probability <- matrix(c(0.5, 0.5, 0.5, 0.5), nrow = 2, byrow = TRUE)
election_values_2 <- simulate_election(
    num_ballots = 50, num_groups = 2, num_candidates = 2, seed = 42,
    prob = artificial_probability
)
election_values_2
```

Let's note that there is a lambda parameter that controls the heterogeneity of group voting. A value of 0 represents full heterogeneity, in contrast to values close to 1. This is explained in detail in the `simulate_election()` documentation.

```{r}
heterogeneity <- simulate_election(
    num_ballots = 50, num_groups = 2, num_candidates = 2, seed = 42,
    lambda = 0.1
)
heterogeneity
```


```{r}
homogeneity <- simulate_election(
    num_ballots = 50, num_groups = 2, num_candidates = 2, seed = 42,
    lambda = 0.9
)
homogeneity
```
